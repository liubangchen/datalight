// DO NOT EDIT : This file is generated by java-to-struct-json
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once

// This file is generated DO NOT EDIT @generated

#include <cstdint>
#include <exception>
#include <iostream>
#include <list>
#include <map>
#include <regex>
#include <set>
#include <string>
#include <tgmath.h>

#include <utility>
#include <folly/Format.h>
#include <nlohmann/json.hpp>
#include "Base64Util.h"
#include "DataSize.h"
#include "Duration.h"

using nlohmann::json;

namespace datalight::protocol
{

extern const char * const PRESTO_PAGES_MIME_TYPE;

extern const char * const PRESTO_CURRENT_STATE_HTTP_HEADER;
extern const char * const PRESTO_MAX_WAIT_HTTP_HEADER;
extern const char * const PRESTO_MAX_SIZE_HTTP_HEADER;
extern const char * const PRESTO_TASK_INSTANCE_ID_HEADER;
extern const char * const PRESTO_PAGE_TOKEN_HEADER;
extern const char * const PRESTO_PAGE_NEXT_TOKEN_HEADER;
extern const char * const PRESTO_BUFFER_COMPLETE_HEADER;

extern const char * const PRESTO_MAX_WAIT_DEFAULT;
extern const char * const PRESTO_MAX_SIZE_DEFAULT;


extern const char * const PRESTO_ABORT_TASK_URL_PARAM;

class Exception : public std::runtime_error
{
public:
    explicit Exception(const std::string & message) : std::runtime_error(message){};
};

class TypeError : public Exception
{
public:
    explicit TypeError(const std::string & message) : Exception(message){};
};

class OutOfRange : public Exception
{
public:
    explicit OutOfRange(const std::string & message) : Exception(message){};
};
class ParseError : public Exception
{
public:
    explicit ParseError(const std::string & message) : Exception(message){};
};

using String = std::string;
using Integer = int;
using Long = int64_t;
using Boolean = bool;
using boolean = bool;

template <typename T>
using List = std::vector<T>;
template <typename T>
using Set = std::set<T>;
template <typename K, typename V>
using Map = std::map<K, V>;

// These will have to be customized
//
using UUID = std::string;

using Subfield = std::string;
using HiveType = std::string;
using Type = std::string;

using DateTime = std::string;
using Locale = std::string;
using TimeZoneKey = long;
using OptionalLong = long;
using URI = std::string;
using SqlFunctionId = std::string;

using QualifiedObjectName = std::string;
using TypeSignature = std::string;

using TableStatisticType = int8_t;
using AcidOperation = int8_t;
using FunctionId = std::string;
using RetryPolicy = int8_t;
using ConnectorId = std::string;
using MemoryPoolId = std::string;
using OutputBufferId = std::string;
using PlanFragmentId = std::string;
using PlanNodeId = std::string;
using QueryId = std::string;
using TaskId = std::string;
using TransactionId = std::string;
struct RuntimeMetric;
using RuntimeStats = Map<String, RuntimeMetric>;
using SplitWeight = int64_t;
struct SourceLocation;

// Add for trino
using CatalogName = std::string;
using Symbol = std::string;
using Expression = std::string;
using DynamicFilterId = std::string;
using Instant = std::string;
//using BucketingVersion = int;
using Metrics = std::string;
using Properties = std::map<std::string, std::string>;
using HiveTypeName = std::string;

template <typename T>
void to_json_key(json & j, const char * key, const T & value)
{
    j[key] = value;
}

template <typename T>
void to_json_key(json & j, const char * key, const std::shared_ptr<T> & value)
{
    if (value != nullptr)
    {
        j[key] = value;
    }
}

template <typename T>
void to_json_key(json & j, const char * key, const T & value, const char * className, const char * typeName, const char * fieldName)
{
    try
    {
        to_json_key(j, key, value);
    }
    catch (json::type_error & e)
    {
        throw TypeError(std::string(e.what()) + " " + className + " " + typeName + " " + fieldName);
    }
}

template <typename T>
void from_json_key(const json & j, const char * key, T & value)
{
    j.at(key).get_to(value);
}

template <typename T>
void from_json_key(const json & j, const char * key, std::shared_ptr<T> & value)
{
    if (j.count(key))
    {
        j.at(key).get_to(value);
    }
}

template <typename T>
void from_json_key(const json & j, const char * key, T & value, const char * className, const char * typeName, const char * fieldName)
{
    try
    {
        from_json_key(j, key, value);
    }
    catch (json::type_error & e)
    {
        throw TypeError(std::string(e.what()) + " " + className + " " + typeName + " " + fieldName);
    }
    catch (json::out_of_range & e)
    {
        throw OutOfRange(std::string(e.what()) + " " + className + " " + typeName + " " + fieldName);
    }
}

struct KeyedSubclass
{
    std::string _type; // This member holds the subtype that was serialized.

    std::string getSubclassKey(const json j);
    virtual ~KeyedSubclass() { }
};

struct JsonEncodedSubclass : public KeyedSubclass
{
    std::string getSubclassKey(const json j);
};

struct Base64EncodedSubclass : public KeyedSubclass
{
    std::string getSubclassKey(const json & j);

    virtual bool operator<(const Base64EncodedSubclass & /* o */) const
    {
        throw std::runtime_error("missing operator<() in Base64EncodedSubclass");
    }
};

}

namespace nlohmann
{
std::string json_map_key(const std::string p);

template <typename T>
void to_json(json & j, const std::shared_ptr<T> & p)
{
    j = *p;
}
template <typename T>
void from_json(const json & j, std::shared_ptr<T> & p)
{
    p = std::make_shared<T>();
    j.get_to(*p);
}

template <typename V>
struct adl_serializer<datalight::protocol::Map<int, V>>
{
    static void to_json(json & j, const datalight::protocol::Map<int, V> & p)
    {
        j = json::object();
        for (auto & el : p)
        {
            j[std::to_string(el.first)] = el.second;
        }
    }

    static void from_json(const json & j, datalight::protocol::Map<int, V> & p)
    {
        for (auto & el : j.items())
        {
            p.insert(std::pair<int, V>(std::stoi(el.key()), el.value().get<V>()));
        }
    }
};

template <typename K, typename V>
struct adl_serializer<datalight::protocol::Map<K, V>>
{
    static void to_json(json & j, const datalight::protocol::Map<K, V> & p)
    {
        j = json::object();
        for (auto & el : p)
        {
            j[json_map_key(el.first)] = el.second;
        }
    }

    static void from_json(const json & j, datalight::protocol::Map<K, V> & p)
    {
        for (auto & el : j.items())
        {
            p.insert(std::pair<K, V>(K(el.key()), el.value().get<V>()));
        }
    }
};
} // namespace nlohmann


// Forward declaration of all abstract types
//
namespace datalight::protocol
{
struct PlanNode : public JsonEncodedSubclass
{
    PlanNodeId id = {};
};
void to_json(json & j, const std::shared_ptr<PlanNode> & p);
void from_json(const json & j, std::shared_ptr<PlanNode> & p);
}
namespace datalight::protocol
{
struct ConnectorTransactionHandle : public JsonEncodedSubclass
{
};
void to_json(json & j, const std::shared_ptr<ConnectorTransactionHandle> & p);
void from_json(const json & j, std::shared_ptr<ConnectorTransactionHandle> & p);
}
namespace datalight::protocol
{
struct ConnectorPartitioningHandle : public JsonEncodedSubclass
{
};
void to_json(json & j, const std::shared_ptr<ConnectorPartitioningHandle> & p);
void from_json(const json & j, std::shared_ptr<ConnectorPartitioningHandle> & p);
}
namespace datalight::protocol
{
struct ConnectorInsertTableHandle : public JsonEncodedSubclass
{
};
void to_json(json & j, const std::shared_ptr<ConnectorInsertTableHandle> & p);
void from_json(const json & j, std::shared_ptr<ConnectorInsertTableHandle> & p);
}
namespace datalight::protocol
{
struct ConnectorSplit : public JsonEncodedSubclass
{
};
void to_json(json & j, const std::shared_ptr<ConnectorSplit> & p);
void from_json(const json & j, std::shared_ptr<ConnectorSplit> & p);
}
namespace datalight::protocol
{
struct ValueSet : public JsonEncodedSubclass
{
};
void to_json(json & j, const std::shared_ptr<ValueSet> & p);
void from_json(const json & j, std::shared_ptr<ValueSet> & p);
}
namespace datalight::protocol
{
struct ExchangeSinkInstanceHandle : public JsonEncodedSubclass
{
};
void to_json(json & j, const std::shared_ptr<ExchangeSinkInstanceHandle> & p);
void from_json(const json & j, std::shared_ptr<ExchangeSinkInstanceHandle> & p);
}
namespace datalight::protocol
{
struct ConnectorTableHandle : public JsonEncodedSubclass
{
};
void to_json(json & j, const std::shared_ptr<ConnectorTableHandle> & p);
void from_json(const json & j, std::shared_ptr<ConnectorTableHandle> & p);
}
namespace datalight::protocol
{
struct ConnectorOutputTableHandle : public JsonEncodedSubclass
{
};
void to_json(json & j, const std::shared_ptr<ConnectorOutputTableHandle> & p);
void from_json(const json & j, std::shared_ptr<ConnectorOutputTableHandle> & p);
}
namespace datalight::protocol
{
struct ColumnHandle : public JsonEncodedSubclass
{
    virtual bool operator<(const ColumnHandle & /* o */) const { throw std::runtime_error("missing operator<() in {class_name} subclass"); }
};
void to_json(json & j, const std::shared_ptr<ColumnHandle> & p);
void from_json(const json & j, std::shared_ptr<ColumnHandle> & p);
}
namespace datalight::protocol
{
struct ExchangeInput : public JsonEncodedSubclass
{
};
void to_json(json & j, const std::shared_ptr<ExchangeInput> & p);
void from_json(const json & j, std::shared_ptr<ExchangeInput> & p);
}
namespace datalight::protocol
{
struct ExchangeSourceHandle : public JsonEncodedSubclass
{
};
void to_json(json & j, const std::shared_ptr<ExchangeSourceHandle> & p);
void from_json(const json & j, std::shared_ptr<ExchangeSourceHandle> & p);
}
namespace datalight::protocol
{
struct WriterTarget : public JsonEncodedSubclass
{
};
void to_json(json & j, const std::shared_ptr<WriterTarget> & p);
void from_json(const json & j, std::shared_ptr<WriterTarget> & p);
}
namespace datalight::protocol
{
struct ConnectorTableExecuteHandle : public JsonEncodedSubclass
{
};
void to_json(json & j, const std::shared_ptr<ConnectorTableExecuteHandle> & p);
void from_json(const json & j, std::shared_ptr<ConnectorTableExecuteHandle> & p);
}

namespace datalight::protocol
{
struct GroupingSetDescriptor
{
    List<Symbol> groupingKeys = {};
    int groupingSetCount = {};
    List<Integer> globalGroupingSets = {};
};
void to_json(json & j, const GroupingSetDescriptor & p);
void from_json(const json & j, GroupingSetDescriptor & p);
}
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
namespace datalight::protocol
{

struct Block
{
    std::string data;
};

void to_json(json & j, const Block & p);

void from_json(const json & j, Block & p);

} // namespace facebook::trino::protocol
namespace datalight::protocol
{
struct Serializable
{
    Type type = {};
    Block block = {};
};
void to_json(json & j, const Serializable & p);
void from_json(const json & j, Serializable & p);
}
namespace datalight::protocol
{
struct NullableValue
{
    Serializable serializable = {};
};
void to_json(json & j, const NullableValue & p);
void from_json(const json & j, NullableValue & p);
}
namespace datalight::protocol
{
struct ArgumentBinding
{
    Expression expression = {};
    NullableValue constant = {};
};
void to_json(json & j, const ArgumentBinding & p);
void from_json(const json & j, ArgumentBinding & p);
}
namespace datalight::protocol
{
struct PartitioningHandle
{
    std::shared_ptr<CatalogName> connectorId = {};
    std::shared_ptr<ConnectorTransactionHandle> transactionHandle = {};
    std::shared_ptr<ConnectorPartitioningHandle> connectorHandle = {};
};
void to_json(json & j, const PartitioningHandle & p);
void from_json(const json & j, PartitioningHandle & p);
}
namespace datalight::protocol
{
struct Partitioning
{
    PartitioningHandle handle = {};
    List<ArgumentBinding> arguments = {};
};
void to_json(json & j, const Partitioning & p);
void from_json(const json & j, Partitioning & p);
}
namespace datalight::protocol
{
struct PartitioningScheme
{
    Partitioning partitioning = {};
    List<Symbol> outputLayout = {};
    std::shared_ptr<Symbol> hashColumn = {};
    bool replicateNullsAndAny = {};
    std::shared_ptr<List<int>> bucketToPartition = {};
};
void to_json(json & j, const PartitioningScheme & p);
void from_json(const json & j, PartitioningScheme & p);
}
namespace datalight::protocol
{
struct LocalCostEstimate
{
    double cpuCost = {};
    double maxMemory = {};
    double networkCost = {};
};
void to_json(json & j, const LocalCostEstimate & p);
void from_json(const json & j, LocalCostEstimate & p);
}
namespace datalight::protocol
{
struct PlanCostEstimate
{
    double cpuCost = {};
    double maxMemory = {};
    double maxMemoryWhenOutputting = {};
    double networkCost = {};
    LocalCostEstimate rootNodeLocalCostEstimate = {};
};
void to_json(json & j, const PlanCostEstimate & p);
void from_json(const json & j, PlanCostEstimate & p);
}
namespace datalight::protocol
{
struct SymbolStatsEstimate
{
    double lowValue = {};
    double highValue = {};
    double nullsFraction = {};
    double averageRowSize = {};
    double distinctValuesCount = {};
};
void to_json(json & j, const SymbolStatsEstimate & p);
void from_json(const json & j, SymbolStatsEstimate & p);
}
namespace datalight::protocol
{
struct PlanNodeStatsEstimate
{
    double outputRowCount = {};
    Map<Symbol, SymbolStatsEstimate> symbolStatistics = {};
};
void to_json(json & j, const PlanNodeStatsEstimate & p);
void from_json(const json & j, PlanNodeStatsEstimate & p);
}
namespace datalight::protocol
{
struct StatsAndCosts
{
    Map<PlanNodeId, PlanNodeStatsEstimate> stats = {};
    Map<PlanNodeId, PlanCostEstimate> costs = {};
};
void to_json(json & j, const StatsAndCosts & p);
void from_json(const json & j, StatsAndCosts & p);
}
namespace datalight::protocol
{
struct PlanFragment
{
    PlanFragmentId id = {};
    std::shared_ptr<PlanNode> root = {};
    Map<Symbol, Type> symbols = {};
    PartitioningHandle partitioning = {};
    List<PlanNodeId> partitionedSources = {};
    PartitioningScheme partitioningScheme = {};
    StatsAndCosts statsAndCosts = {};
    std::shared_ptr<String> jsonRepresentation = {};
};
void to_json(json & j, const PlanFragment & p);
void from_json(const json & j, PlanFragment & p);
}
namespace datalight::protocol
{
enum class BlockedReason
{
    WAITING_FOR_MEMORY
};
extern void to_json(json & j, const BlockedReason & e);
extern void from_json(const json & j, BlockedReason & e);
}
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
namespace datalight::protocol
{

std::ostream & operator<<(std::ostream & os, const DataSize & d);

void to_json(nlohmann::json & j, const DataSize & p);
void from_json(const nlohmann::json & j, DataSize & p);

} // namespace facebook::trino::protocol
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
namespace datalight::protocol
{
struct OperatorInfo
{
};
void to_json(json & j, const OperatorInfo & p);
void from_json(const json & j, OperatorInfo & p);
} // namespace facebook::trino::protocol
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


namespace datalight::protocol
{

std::ostream & operator<<(std::ostream & os, const Duration & d);

void to_json(json & j, const Duration & p);
void from_json(const json & j, Duration & p);

} // namespace facebook::trino::protocol
namespace datalight::protocol
{
struct OperatorStats
{
    int stageId = {};
    int pipelineId = {};
    int operatorId = {};
    PlanNodeId planNodeId = {};
    String operatorType = {};
    int64_t totalDrivers = {};
    int64_t addInputCalls = {};
    Duration addInputWall = {};
    Duration addInputCpu = {};
    DataSize physicalInputDataSize = {};
    int64_t physicalInputPositions = {};
    Duration physicalInputReadTime = {};
    DataSize internalNetworkInputDataSize = {};
    int64_t internalNetworkInputPositions = {};
    DataSize rawInputDataSize = {};
    DataSize inputDataSize = {};
    int64_t inputPositions = {};
    double sumSquaredInputPositions = {};
    int64_t getOutputCalls = {};
    Duration getOutputWall = {};
    Duration getOutputCpu = {};
    DataSize outputDataSize = {};
    int64_t outputPositions = {};
    int64_t dynamicFilterSplitsProcessed = {};
    Metrics metrics = {};
    Metrics connectorMetrics = {};
    DataSize physicalWrittenDataSize = {};
    Duration blockedWall = {};
    int64_t finishCalls = {};
    Duration finishWall = {};
    Duration finishCpu = {};
    DataSize userMemoryReservation = {};
    DataSize revocableMemoryReservation = {};
    DataSize peakUserMemoryReservation = {};
    DataSize peakRevocableMemoryReservation = {};
    DataSize peakTotalMemoryReservation = {};
    DataSize spilledDataSize = {};
    std::shared_ptr<BlockedReason> blockedReason = {};
    OperatorInfo info = {};
};
void to_json(json & j, const OperatorStats & p);
void from_json(const json & j, OperatorStats & p);
}
namespace datalight::protocol
{
struct DriverStats
{
    DateTime createTime = {};
    DateTime startTime = {};
    DateTime endTime = {};
    Duration queuedTime = {};
    Duration elapsedTime = {};
    DataSize userMemoryReservation = {};
    DataSize revocableMemoryReservation = {};
    Duration totalScheduledTime = {};
    Duration totalCpuTime = {};
    Duration totalBlockedTime = {};
    bool fullyBlocked = {};
    List<BlockedReason> blockedReasons = {};
    DataSize physicalInputDataSize = {};
    int64_t physicalInputPositions = {};
    Duration physicalInputReadTime = {};
    DataSize internalNetworkInputDataSize = {};
    int64_t internalNetworkInputPositions = {};
    DataSize rawInputDataSize = {};
    int64_t rawInputPositions = {};
    Duration rawInputReadTime = {};
    DataSize processedInputDataSize = {};
    int64_t processedInputPositions = {};
    Duration inputBlockedTime = {};
    DataSize outputDataSize = {};
    int64_t outputPositions = {};
    Duration outputBlockedTime = {};
    DataSize physicalWrittenDataSize = {};
    List<OperatorStats> operatorStats = {};
};
void to_json(json & j, const DriverStats & p);
void from_json(const json & j, DriverStats & p);
}
namespace datalight::protocol
{
struct DistributionSnapshot
{
    double count = {};
    double total = {};
    double p01 = {};
    double p05 = {};
    double p10 = {};
    double p25 = {};
    double p50 = {};
    double p75 = {};
    double p90 = {};
    double p95 = {};
    double p99 = {};
    double min = {};
    double max = {};
    double avg = {};
};
void to_json(json & j, const DistributionSnapshot & p);
void from_json(const json & j, DistributionSnapshot & p);
}
namespace datalight::protocol
{
struct MemoryAllocation
{
    String tag = {};
    int64_t allocation = {};
};
void to_json(json & j, const MemoryAllocation & p);
void from_json(const json & j, MemoryAllocation & p);
}
namespace datalight::protocol
{
struct MemoryPoolInfo
{
    int64_t maxBytes = {};
    int64_t reservedBytes = {};
    int64_t reservedRevocableBytes = {};
    Map<QueryId, Long> queryMemoryReservations = {};
    Map<QueryId, List<MemoryAllocation>> queryMemoryAllocations = {};
    Map<QueryId, Long> queryMemoryRevocableReservations = {};
    Map<String, Long> taskMemoryReservations = {};
    Map<String, Long> taskMemoryRevocableReservations = {};
};
void to_json(json & j, const MemoryPoolInfo & p);
void from_json(const json & j, MemoryPoolInfo & p);
}
namespace datalight::protocol
{
struct InsertTableHandle
{
    CatalogName catalogName = {};
    std::shared_ptr<ConnectorTransactionHandle> transactionHandle = {};
    std::shared_ptr<ConnectorInsertTableHandle> connectorHandle = {};
};
void to_json(json & j, const InsertTableHandle & p);
void from_json(const json & j, InsertTableHandle & p);
}
namespace datalight::protocol
{
struct SchemaTableName
{
    String schema = {};
    String table = {};
};
void to_json(json & j, const SchemaTableName & p);
void from_json(const json & j, SchemaTableName & p);
}
namespace datalight::protocol
{
struct InsertTarget
{
    InsertTableHandle handle = {};
    SchemaTableName schemaTableName = {};
    bool reportingWrittenBytesSupported = {};
};
void to_json(json & j, const InsertTarget & p);
void from_json(const json & j, InsertTarget & p);
}
namespace datalight::protocol
{
struct FileStatus
{
    String filePath = {};
    int64_t fileSize = {};
};
void to_json(json & j, const FileStatus & p);
void from_json(const json & j, FileStatus & p);
}
namespace datalight::protocol
{
struct Split
{
    CatalogName catalogName = {};
    std::shared_ptr<ConnectorSplit> connectorSplit = {};
};
void to_json(json & j, const Split & p);
void from_json(const json & j, Split & p);
}
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
namespace datalight::protocol
{

struct ScheduledSplit
{
    long sequenceId = {};
    PlanNodeId planNodeId = {}; // dependency
    Split split = {};

    bool operator<(const ScheduledSplit & o) const { return sequenceId < o.sequenceId; }
};

void to_json(json & j, const ScheduledSplit & p);
void from_json(const json & j, ScheduledSplit & p);

} // namespace facebook::trino::protocol
namespace datalight::protocol
{
enum class TaskState
{
    PLANNED,
    RUNNING,
    FLUSHING,
    FINISHED,
    CANCELED,
    ABORTED,
    FAILED
};
extern void to_json(json & j, const TaskState & e);
extern void from_json(const json & j, TaskState & e);
}
namespace datalight::protocol
{
enum class ErrorType
{
    USER_ERROR,
    INTERNAL_ERROR,
    INSUFFICIENT_RESOURCES,
    EXTERNAL
};
extern void to_json(json & j, const ErrorType & e);
extern void from_json(const json & j, ErrorType & e);
}
namespace datalight::protocol
{
struct ErrorCode
{
    int code = {};
    String name = {};
    ErrorType type = {};
};
void to_json(json & j, const ErrorCode & p);
void from_json(const json & j, ErrorCode & p);
}
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

namespace datalight::protocol
{

using HostAddress = std::string;

} //
namespace datalight::protocol
{
struct ErrorLocation
{
    int lineNumber = {};
    int columnNumber = {};
};
void to_json(json & j, const ErrorLocation & p);
void from_json(const json & j, ErrorLocation & p);
}
namespace datalight::protocol
{
struct ExecutionFailureInfo
{
    String type = {};
    String message = {};
    std::shared_ptr<ExecutionFailureInfo> cause = {};
    List<ExecutionFailureInfo> suppressed = {};
    List<String> stack = {};
    ErrorLocation errorLocation = {};
    ErrorCode errorCode = {};
    HostAddress remoteHost = {};
};
void to_json(json & j, const ExecutionFailureInfo & p);
void from_json(const json & j, ExecutionFailureInfo & p);
}
namespace datalight::protocol
{
struct TaskStatus
{
    TaskId taskId = {};
    String taskInstanceId = {};
    int64_t version = {};
    TaskState state = {};
    URI self = {};
    String nodeId = {};
    List<ExecutionFailureInfo> failures = {};
    int queuedPartitionedDrivers = {};
    int runningPartitionedDrivers = {};
    bool outputBufferOverutilized = {};
    DataSize physicalWrittenDataSize = {};
    DataSize memoryReservation = {};
    DataSize peakMemoryReservation = {};
    DataSize revocableMemoryReservation = {};
    int64_t fullGcCount = {};
    Duration fullGcTime = {};
    int64_t dynamicFiltersVersion = {};
    int64_t queuedPartitionedSplitsWeight = {};
    int64_t runningPartitionedSplitsWeight = {};
};
void to_json(json & j, const TaskStatus & p);
void from_json(const json & j, TaskStatus & p);
}
namespace datalight::protocol
{
struct PipelineStats
{
    int pipelineId = {};
    DateTime firstStartTime = {};
    DateTime lastStartTime = {};
    DateTime lastEndTime = {};
    bool inputPipeline = {};
    bool outputPipeline = {};
    int totalDrivers = {};
    int queuedDrivers = {};
    int queuedPartitionedDrivers = {};
    int64_t queuedPartitionedSplitsWeight = {};
    int runningDrivers = {};
    int runningPartitionedDrivers = {};
    int64_t runningPartitionedSplitsWeight = {};
    int blockedDrivers = {};
    int completedDrivers = {};
    DataSize userMemoryReservation = {};
    DataSize revocableMemoryReservation = {};
    DistributionSnapshot queuedTime = {};
    DistributionSnapshot elapsedTime = {};
    Duration totalScheduledTime = {};
    Duration totalCpuTime = {};
    Duration totalBlockedTime = {};
    bool fullyBlocked = {};
    List<BlockedReason> blockedReasons = {};
    DataSize physicalInputDataSize = {};
    int64_t physicalInputPositions = {};
    Duration physicalInputReadTime = {};
    DataSize internalNetworkInputDataSize = {};
    int64_t internalNetworkInputPositions = {};
    DataSize rawInputDataSize = {};
    int64_t rawInputPositions = {};
    DataSize processedInputDataSize = {};
    int64_t processedInputPositions = {};
    Duration inputBlockedTime = {};
    DataSize outputDataSize = {};
    int64_t outputPositions = {};
    Duration outputBlockedTime = {};
    DataSize physicalWrittenDataSize = {};
    List<OperatorStats> operatorSummaries = {};
    List<DriverStats> drivers = {};
};
void to_json(json & j, const PipelineStats & p);
void from_json(const json & j, PipelineStats & p);
}
namespace datalight::protocol
{
struct TaskStats
{
    DateTime createTime = {};
    DateTime firstStartTime = {};
    DateTime lastStartTime = {};
    DateTime lastEndTime = {};
    DateTime endTime = {};
    Duration elapsedTime = {};
    Duration queuedTime = {};
    int totalDrivers = {};
    int queuedDrivers = {};
    int queuedPartitionedDrivers = {};
    int64_t queuedPartitionedSplitsWeight = {};
    int runningDrivers = {};
    int runningPartitionedDrivers = {};
    int64_t runningPartitionedSplitsWeight = {};
    int blockedDrivers = {};
    int completedDrivers = {};
    double cumulativeUserMemory = {};
    DataSize userMemoryReservation = {};
    DataSize peakUserMemoryReservation = {};
    DataSize revocableMemoryReservation = {};
    Duration totalScheduledTime = {};
    Duration totalCpuTime = {};
    Duration totalBlockedTime = {};
    bool fullyBlocked = {};
    List<BlockedReason> blockedReasons = {};
    DataSize physicalInputDataSize = {};
    int64_t physicalInputPositions = {};
    Duration physicalInputReadTime = {};
    DataSize internalNetworkInputDataSize = {};
    int64_t internalNetworkInputPositions = {};
    DataSize rawInputDataSize = {};
    int64_t rawInputPositions = {};
    DataSize processedInputDataSize = {};
    int64_t processedInputPositions = {};
    Duration inputBlockedTime = {};
    DataSize outputDataSize = {};
    int64_t outputPositions = {};
    Duration outputBlockedTime = {};
    DataSize physicalWrittenDataSize = {};
    int fullGcCount = {};
    Duration fullGcTime = {};
    List<PipelineStats> pipelines = {};
};
void to_json(json & j, const TaskStats & p);
void from_json(const json & j, TaskStats & p);
}
namespace datalight::protocol
{
enum class BufferState
{
    OPEN,
    NO_MORE_BUFFERS,
    NO_MORE_PAGES,
    FLUSHING,
    FINISHED,
    ABORTED,
    FAILED
};
extern void to_json(json & j, const BufferState & e);
extern void from_json(const json & j, BufferState & e);
}
namespace datalight::protocol
{
struct PageBufferInfo
{
    int partition = {};
    int64_t bufferedPages = {};
    int64_t bufferedBytes = {};
    int64_t rowsAdded = {};
    int64_t pagesAdded = {};
};
void to_json(json & j, const PageBufferInfo & p);
void from_json(const json & j, PageBufferInfo & p);
}
namespace datalight::protocol
{
struct BufferInfo
{
    OutputBufferId bufferId = {};
    bool finished = {};
    int bufferedPages = {};
    int64_t pagesSent = {};
    PageBufferInfo pageBufferInfo = {};
};
void to_json(json & j, const BufferInfo & p);
void from_json(const json & j, BufferInfo & p);
}
namespace datalight::protocol
{
struct OutputBufferInfo
{
    String type = {};
    BufferState state = {};
    bool canAddBuffers = {};
    bool canAddPages = {};
    int64_t totalBufferedBytes = {};
    int64_t totalBufferedPages = {};
    int64_t totalRowsSent = {};
    int64_t totalPagesSent = {};
    List<BufferInfo> buffers = {};
};
void to_json(json & j, const OutputBufferInfo & p);
void from_json(const json & j, OutputBufferInfo & p);
}
namespace datalight::protocol
{
struct TaskInfo
{
    TaskStatus taskStatus = {};
    DateTime lastHeartbeat = {};
    OutputBufferInfo outputBuffers = {};
    List<PlanNodeId> noMoreSplits = {};
    TaskStats stats = {};
    std::shared_ptr<DataSize> estimatedMemory = {};
    bool needsPlan = {};
};
void to_json(json & j, const TaskInfo & p);
void from_json(const json & j, TaskInfo & p);
}
namespace datalight::protocol
{
struct ResourceEstimates
{
    std::shared_ptr<Duration> executionTime = {};
    std::shared_ptr<Duration> cpuTime = {};
    std::shared_ptr<Long> peakMemoryBytes = {};
};
void to_json(json & j, const ResourceEstimates & p);
void from_json(const json & j, ResourceEstimates & p);
}
namespace datalight::protocol
{
enum class BucketingVersion
{
    BUCKETING_V1
};
extern void to_json(json & j, const BucketingVersion & e);
extern void from_json(const json & j, BucketingVersion & e);
}
namespace datalight::protocol
{
enum class ColumnType
{
    PARTITION_KEY,
    REGULAR,
    SYNTHESIZED
};
extern void to_json(json & j, const ColumnType & e);
extern void from_json(const json & j, ColumnType & e);
}
namespace datalight::protocol
{
struct HiveColumnProjectionInfo
{
    List<Integer> dereferenceIndices = {};
    List<String> dereferenceNames = {};
    HiveType hiveType = {};
    Type type = {};
};
void to_json(json & j, const HiveColumnProjectionInfo & p);
void from_json(const json & j, HiveColumnProjectionInfo & p);
}
namespace datalight::protocol
{
struct HiveColumnHandle : public ColumnHandle
{
    String baseColumnName = {};
    int baseHiveColumnIndex = {};
    HiveType baseHiveType = {};
    Type baseType = {};
    std::shared_ptr<HiveColumnProjectionInfo> hiveColumnProjectionInfo = {};
    ColumnType columnType = {};
    std::shared_ptr<String> comment = {};

    HiveColumnHandle() noexcept;
};
void to_json(json & j, const HiveColumnHandle & p);
void from_json(const json & j, HiveColumnHandle & p);
}
namespace datalight::protocol
{
struct BucketValidation
{
    BucketingVersion bucketingVersion = {};
    int bucketCount = {};
    List<HiveColumnHandle> bucketColumns = {};
};
void to_json(json & j, const BucketValidation & p);
void from_json(const json & j, BucketValidation & p);
}
namespace datalight::protocol
{
struct BucketConversion
{
    BucketingVersion bucketingVersion = {};
    int tableBucketCount = {};
    int partitionBucketCount = {};
    List<HiveColumnHandle> bucketColumnHandles = {};
};
void to_json(json & j, const BucketConversion & p);
void from_json(const json & j, BucketConversion & p);
}
namespace datalight::protocol
{
struct TableToPartitionMapping
{
    std::shared_ptr<Map<Integer, Integer>> tableToPartitionColumns = {};
    Map<Integer, HiveTypeName> partitionColumnCoercions = {};
};
void to_json(json & j, const TableToPartitionMapping & p);
void from_json(const json & j, TableToPartitionMapping & p);
}
namespace datalight::protocol
{
struct HivePartitionKey
{
    String name = {};
    String value = {};
};
void to_json(json & j, const HivePartitionKey & p);
void from_json(const json & j, HivePartitionKey & p);
}
namespace datalight::protocol
{
struct DeleteDeltaInfo
{
    String directoryName = {};
};
void to_json(json & j, const DeleteDeltaInfo & p);
void from_json(const json & j, DeleteDeltaInfo & p);
}
namespace datalight::protocol
{
struct OriginalFileInfo
{
    String name = {};
    int64_t fileSize = {};
};
void to_json(json & j, const OriginalFileInfo & p);
void from_json(const json & j, OriginalFileInfo & p);
}
namespace datalight::protocol
{
struct AcidInfo
{
    String partitionLocation = {};
    List<DeleteDeltaInfo> deleteDeltas = {};
    List<OriginalFileInfo> originalFiles = {};
    int bucketId = {};
    bool orcAcidVersionValidated = {};
};
void to_json(json & j, const AcidInfo & p);
void from_json(const json & j, AcidInfo & p);
}
namespace datalight::protocol
{
struct HiveSplit : public ConnectorSplit
{
    String database = {};
    String table = {};
    String partitionName = {};
    String path = {};
    int64_t start = {};
    int64_t length = {};
    int64_t estimatedFileSize = {};
    int64_t fileModifiedTime = {};
    Properties schema = {};
    List<HivePartitionKey> partitionKeys = {};
    List<HostAddress> addresses = {};
    std::shared_ptr<int> readBucketNumber = {};
    std::shared_ptr<int> tableBucketNumber = {};
    int statementId = {};
    bool forceLocalScheduling = {};
    TableToPartitionMapping tableToPartitionMapping = {};
    std::shared_ptr<BucketConversion> bucketConversion = {};
    std::shared_ptr<BucketValidation> bucketValidation = {};
    bool s3SelectPushdownEnabled = {};
    std::shared_ptr<AcidInfo> acidInfo = {};
    int64_t splitNumber = {};
    SplitWeight splitWeight = {};

    HiveSplit() noexcept;
};
void to_json(json & j, const HiveSplit & p);
void from_json(const json & j, HiveSplit & p);
}
namespace datalight::protocol
{
enum class SortOrder
{
    ASC_NULLS_FIRST,
    ASC_NULLS_LAST,
    DESC_NULLS_FIRST,
    DESC_NULLS_LAST
};
extern void to_json(json & j, const SortOrder & e);
extern void from_json(const json & j, SortOrder & e);
}
namespace datalight::protocol
{
struct OrderingScheme
{
    List<Symbol> orderBy = {};
    Map<Symbol, SortOrder> orderings = {};
};
void to_json(json & j, const OrderingScheme & p);
void from_json(const json & j, OrderingScheme & p);
}
namespace datalight::protocol
{
enum class FunctionKind
{
    SCALAR,
    AGGREGATE,
    WINDOW,
    TABLE
};
extern void to_json(json & j, const FunctionKind & e);
extern void from_json(const json & j, FunctionKind & e);
}
namespace datalight::protocol
{
struct BoundSignature
{
    String name = {};
    Type returnType = {};
    List<Type> argumentTypes = {};
};
void to_json(json & j, const BoundSignature & p);
void from_json(const json & j, BoundSignature & p);
}
namespace datalight::protocol
{
struct FunctionNullability
{
    bool returnNullable = {};
    List<Boolean> argumentNullable = {};
};
void to_json(json & j, const FunctionNullability & p);
void from_json(const json & j, FunctionNullability & p);
}
namespace datalight::protocol
{
struct ResolvedFunction
{
    BoundSignature signature = {};
    FunctionId id = {};
    FunctionKind functionKind = {};
    bool deterministic = {};
    FunctionNullability nullability = {};
    Map<TypeSignature, Type> typeDependencies = {};
    List<ResolvedFunction> functionDependencies = {};
};
void to_json(json & j, const ResolvedFunction & p);
void from_json(const json & j, ResolvedFunction & p);
}
namespace datalight::protocol
{
struct Aggregation
{
    ResolvedFunction resolvedFunction = {};
    List<Expression> arguments = {};
    bool distinct = {};
    std::shared_ptr<Symbol> filter = {};
    std::shared_ptr<OrderingScheme> orderingScheme = {};
    std::shared_ptr<Symbol> mask = {};
};
void to_json(json & j, const Aggregation & p);
void from_json(const json & j, Aggregation & p);
}
namespace datalight::protocol
{
enum class AggregationNodeStep
{
    PARTIAL,
    FINAL,
    INTERMEDIATE,
    SINGLE
};
extern void to_json(json & j, const AggregationNodeStep & e);
extern void from_json(const json & j, AggregationNodeStep & e);
}
namespace datalight::protocol
{
struct AggregationNode : public PlanNode
{
    std::shared_ptr<PlanNode> source = {};
    Map<Symbol, Aggregation> aggregations = {};
    GroupingSetDescriptor groupingSets = {};
    List<Symbol> preGroupedSymbols = {};
    AggregationNodeStep step = {};
    std::shared_ptr<Symbol> hashSymbol = {};
    std::shared_ptr<Symbol> groupIdSymbol = {};

    AggregationNode() noexcept;
};
void to_json(json & j, const AggregationNode & p);
void from_json(const json & j, AggregationNode & p);
}
namespace datalight::protocol
{
struct Domain
{
    std::shared_ptr<ValueSet> values = {};
    bool nullAllowed = {};
};
void to_json(json & j, const Domain & p);
void from_json(const json & j, Domain & p);
}
namespace datalight::protocol
{
struct SplitAssignment
{
    PlanNodeId planNodeId = {};
    List<ScheduledSplit> splits = {};
    bool noMoreSplits = {};
};
void to_json(json & j, const SplitAssignment & p);
void from_json(const json & j, SplitAssignment & p);
}
namespace datalight::protocol
{
enum class BufferType
{
    PARTITIONED,
    BROADCAST,
    ARBITRARY,
    SPOOL
};
extern void to_json(json & j, const BufferType & e);
extern void from_json(const json & j, BufferType & e);
}
namespace datalight::protocol
{
struct OutputBuffers
{
    BufferType type = {};
    int64_t version = {};
    bool noMoreBufferIds = {};
    Map<OutputBufferId, Integer> buffers = {};
    std::shared_ptr<ExchangeSinkInstanceHandle> exchangeSinkInstanceHandle = {};
};
void to_json(json & j, const OutputBuffers & p);
void from_json(const json & j, OutputBuffers & p);
}
namespace datalight::protocol
{
enum class SelectedRoleType
{
    ROLE,
    ALL,
    NONE
};
extern void to_json(json & j, const SelectedRoleType & e);
extern void from_json(const json & j, SelectedRoleType & e);
}
namespace datalight::protocol
{
struct SelectedRole
{
    SelectedRoleType type = {};
    std::shared_ptr<String> role = {};
};
void to_json(json & j, const SelectedRole & p);
void from_json(const json & j, SelectedRole & p);
}
namespace datalight::protocol
{
struct SqlPath
{
    std::shared_ptr<String> rawPath = {};
};
void to_json(json & j, const SqlPath & p);
void from_json(const json & j, SqlPath & p);
}
namespace datalight::protocol
{
struct SessionRepresentation
{
    String queryId = {};
    std::shared_ptr<TransactionId> transactionId = {};
    bool clientTransactionSupport = {};
    String user = {};
    List<String> groups = {};
    std::shared_ptr<String> principal = {};
    List<String> enabledRoles = {};
    std::shared_ptr<String> source = {};
    std::shared_ptr<String> catalog = {};
    std::shared_ptr<String> schema = {};
    SqlPath path = {};
    std::shared_ptr<String> traceToken = {};
    TimeZoneKey timeZoneKey = {};
    Locale locale = {};
    std::shared_ptr<String> remoteUserAddress = {};
    std::shared_ptr<String> userAgent = {};
    std::shared_ptr<String> clientInfo = {};
    List<String> clientTags = {};
    List<String> clientCapabilities = {};
    ResourceEstimates resourceEstimates = {};
    Instant start = {};
    Map<String, String> systemProperties = {};
    Map<String, Map<String, String>> catalogProperties = {};
    Map<String, SelectedRole> catalogRoles = {};
    Map<String, String> preparedStatements = {};
    String protocolName = {};
};
void to_json(json & j, const SessionRepresentation & p);
void from_json(const json & j, SessionRepresentation & p);
}
namespace datalight::protocol
{
struct TaskUpdateRequest
{
    SessionRepresentation session = {};
    Map<String, String> extraCredentials = {};
    std::shared_ptr<PlanFragment> fragment = {};
    List<SplitAssignment> splitAssignments = {};
    OutputBuffers outputIds = {};
    Map<DynamicFilterId, Domain> dynamicFilterDomains = {};
};
void to_json(json & j, const TaskUpdateRequest & p);
void from_json(const json & j, TaskUpdateRequest & p);
}
namespace datalight::protocol
{
struct Column
{
    String name = {};
    HiveType type = {};
    std::shared_ptr<String> comment = {};
};
void to_json(json & j, const Column & p);
void from_json(const json & j, Column & p);
}
namespace datalight::protocol
{
struct PlanNodeStatsAndCostSummary
{
    double outputRowCount = {};
    double outputSizeInBytes = {};
    double cpuCost = {};
    double memoryCost = {};
    double networkCost = {};
};
void to_json(json & j, const PlanNodeStatsAndCostSummary & p);
void from_json(const json & j, PlanNodeStatsAndCostSummary & p);
}
namespace datalight::protocol
{
enum class ExchangeNodeScope
{
    LOCAL,
    REMOTE
};
extern void to_json(json & j, const ExchangeNodeScope & e);
extern void from_json(const json & j, ExchangeNodeScope & e);
}
namespace datalight::protocol
{
enum class ExchangeNodeType
{
    GATHER,
    REPARTITION,
    REPLICATE,
};
extern void to_json(json & j, const ExchangeNodeType & e);
extern void from_json(const json & j, ExchangeNodeType & e);
}
namespace datalight::protocol
{
struct ExchangeNode : public PlanNode
{
    ExchangeNodeType type = {};
    ExchangeNodeScope scope = {};
    PartitioningScheme partitioningScheme = {};
    List<std::shared_ptr<PlanNode>> sources = {};
    List<List<Symbol>> inputs = {};
    std::shared_ptr<OrderingScheme> orderingScheme = {};

    ExchangeNode() noexcept;
};
void to_json(json & j, const ExchangeNode & p);
void from_json(const json & j, ExchangeNode & p);
}
namespace datalight::protocol
{
struct RemoteSourceNode : public PlanNode
{
    List<PlanFragmentId> sourceFragmentIds = {};
    List<Symbol> outputs = {};
    std::shared_ptr<OrderingScheme> orderingScheme = {};
    ExchangeNodeType exchangeType = {};
    RetryPolicy retryPolicy = {};

    RemoteSourceNode() noexcept;
};
void to_json(json & j, const RemoteSourceNode & p);
void from_json(const json & j, RemoteSourceNode & p);
}
namespace datalight::protocol
{
struct EmptySplit : public ConnectorSplit
{
    CatalogName catalogName = {};

    EmptySplit() noexcept;
};
void to_json(json & j, const EmptySplit & p);
void from_json(const json & j, EmptySplit & p);
}
namespace datalight::protocol
{
struct DirectExchangeInput : public ExchangeInput
{
    TaskId taskId = {};
    String location = {};

    DirectExchangeInput() noexcept;
};
void to_json(json & j, const DirectExchangeInput & p);
void from_json(const json & j, DirectExchangeInput & p);
}
namespace datalight::protocol
{
enum class Order
{
    ASCENDING,
    DESCENDING
};
extern void to_json(json & j, const Order & e);
extern void from_json(const json & j, Order & e);
}
namespace datalight::protocol
{
struct SortingColumn
{
    String columnName = {};
    Order order = {};
};
void to_json(json & j, const SortingColumn & p);
void from_json(const json & j, SortingColumn & p);
}
namespace datalight::protocol
{
struct TableHandle
{
    CatalogName catalogName = {};
    std::shared_ptr<ConnectorTableHandle> connectorHandle = {};
    std::shared_ptr<ConnectorTransactionHandle> transaction = {};
};
void to_json(json & j, const TableHandle & p);
void from_json(const json & j, TableHandle & p);
}
namespace datalight::protocol
{
struct DeleteTarget
{
    std::shared_ptr<TableHandle> handle = {};
    SchemaTableName schemaTableName = {};
};
void to_json(json & j, const DeleteTarget & p);
void from_json(const json & j, DeleteTarget & p);
}
namespace datalight::protocol
{
struct OutputTableHandle
{
    CatalogName catalogName = {};
    SchemaTableName tableName = {};
    std::shared_ptr<ConnectorTransactionHandle> transactionHandle = {};
    std::shared_ptr<ConnectorOutputTableHandle> connectorHandle = {};
};
void to_json(json & j, const OutputTableHandle & p);
void from_json(const json & j, OutputTableHandle & p);
}
namespace datalight::protocol
{
struct CreateTarget
{
    OutputTableHandle handle = {};
    SchemaTableName schemaTableName = {};
    bool reportingWrittenBytesSupported = {};
};
void to_json(json & j, const CreateTarget & p);
void from_json(const json & j, CreateTarget & p);
}
namespace datalight::protocol
{
struct HiveUpdateProcessor
{
    List<HiveColumnHandle> allColumns = {};
    List<HiveColumnHandle> updatedColumns = {};
};
void to_json(json & j, const HiveUpdateProcessor & p);
void from_json(const json & j, HiveUpdateProcessor & p);
}
namespace datalight::protocol
{
enum class WriteMode
{
    STAGE_AND_MOVE_TO_TARGET_DIRECTORY,
    DIRECT_TO_TARGET_NEW_DIRECTORY,
    DIRECT_TO_TARGET_EXISTING_DIRECTORY
};
extern void to_json(json & j, const WriteMode & e);
extern void from_json(const json & j, WriteMode & e);
}
namespace datalight::protocol
{
struct LocationHandle
{
    String targetPath = {};
    String writePath = {};
    bool isExistingTable = {};
    WriteMode writeMode = {};
};
void to_json(json & j, const LocationHandle & p);
void from_json(const json & j, LocationHandle & p);
}
namespace datalight::protocol
{
struct StorageFormat
{
    String serde = {};
    String inputFormat = {};
    String outputFormat = {};
};
void to_json(json & j, const StorageFormat & p);
void from_json(const json & j, StorageFormat & p);
}
namespace datalight::protocol
{
struct HivePartitioningHandle : public ConnectorPartitioningHandle
{
    BucketingVersion bucketingVersion = {};
    int bucketCount = {};
    List<HiveType> hiveBucketTypes = {};
    std::shared_ptr<int> maxCompatibleBucketCount = {};
    bool usePartitionedBucketing = {};

    HivePartitioningHandle() noexcept;
};
void to_json(json & j, const HivePartitioningHandle & p);
void from_json(const json & j, HivePartitioningHandle & p);
}
namespace datalight::protocol
{
struct SortNode
{
    PlanNodeId id = {};
    std::shared_ptr<PlanNode> source = {};
    OrderingScheme orderingScheme = {};
    bool partial = {};
};
void to_json(json & j, const SortNode & p);
void from_json(const json & j, SortNode & p);
}
namespace datalight::protocol
{
struct UpdateTarget : public WriterTarget
{
    std::shared_ptr<TableHandle> handle = {};
    SchemaTableName schemaTableName = {};
    List<String> updatedColumns = {};
    List<std::shared_ptr<ColumnHandle>> updatedColumnHandles = {};

    UpdateTarget() noexcept;
};
void to_json(json & j, const UpdateTarget & p);
void from_json(const json & j, UpdateTarget & p);
}
namespace datalight::protocol
{
struct StatisticAggregations
{
    Map<Symbol, Aggregation> aggregations = {};
    List<Symbol> groupingSymbols = {};
};
void to_json(json & j, const StatisticAggregations & p);
void from_json(const json & j, StatisticAggregations & p);
}
namespace datalight::protocol
{
struct NodeVersion
{
    String version = {};
};
void to_json(json & j, const NodeVersion & p);
void from_json(const json & j, NodeVersion & p);
}
namespace datalight::protocol
{
struct EquiJoinClause
{
    Symbol left = {};
    Symbol right = {};
};
void to_json(json & j, const EquiJoinClause & p);
void from_json(const json & j, EquiJoinClause & p);
}
namespace datalight::protocol
{
struct ValuesNode : public PlanNode
{
    List<Symbol> outputSymbols = {};
    int rowCount = {};
    std::shared_ptr<List<Expression>> rows = {};

    ValuesNode() noexcept;
};
void to_json(json & j, const ValuesNode & p);
void from_json(const json & j, ValuesNode & p);
}
namespace datalight::protocol
{
enum class JoinNodeType
{
    INNER,
    LEFT,
    RIGHT,
    FULL
};
extern void to_json(json & j, const JoinNodeType & e);
extern void from_json(const json & j, JoinNodeType & e);
}
namespace datalight::protocol
{
enum class DistributionType
{
    PARTITIONED,
    REPLICATED,
};
extern void to_json(json & j, const DistributionType & e);
extern void from_json(const json & j, DistributionType & e);
}
namespace datalight::protocol
{
struct JoinNode : public PlanNode
{
    JoinNodeType type = {};
    std::shared_ptr<PlanNode> left = {};
    std::shared_ptr<PlanNode> right = {};
    List<EquiJoinClause> criteria = {};
    List<Symbol> leftOutputSymbols = {};
    List<Symbol> rightOutputSymbols = {};
    bool maySkipOutputDuplicates = {};
    std::shared_ptr<Expression> filter = {};
    std::shared_ptr<Symbol> leftHashSymbol = {};
    std::shared_ptr<Symbol> rightHashSymbol = {};
    std::shared_ptr<DistributionType> distributionType = {};
    std::shared_ptr<Boolean> spillable = {};
    Map<DynamicFilterId, Symbol> dynamicFilters = {};
    std::shared_ptr<PlanNodeStatsAndCostSummary> reorderJoinStatsAndCost = {};

    JoinNode() noexcept;
};
void to_json(json & j, const JoinNode & p);
void from_json(const json & j, JoinNode & p);
}
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
namespace datalight::protocol
{

template <typename T>
struct pointerDerefCompare
{
    bool operator()(const std::shared_ptr<T> & a, const std::shared_ptr<T> & b) const { return *a < *b; }
};

template <typename T>
struct TupleDomain
{
    std::shared_ptr<Map<T, Domain>> domains;
};

template <typename T>
struct TupleDomain<std::shared_ptr<T>>
{
    std::shared_ptr<std::map<std::shared_ptr<T>, Domain, pointerDerefCompare<T>>> domains;
};

template <class T>
struct ColumnDomain
{
    T column;
    Domain domain; // dependency
};

}

namespace nlohmann
{

template <typename T>
struct adl_serializer<datalight::protocol::ColumnDomain<T>>
{
    static void to_json(json & j, const datalight::protocol::ColumnDomain<T> & p)
    {
        datalight::protocol::to_json_key(j, "column", p.column, "ColumnDomain", "T", "column");
        datalight::protocol::to_json_key(j, "domain", p.domain, "ColumnDomain", "Domain", "domain");
    }

    static void from_json(const json & j, datalight::protocol::ColumnDomain<T> & p)
    {
        datalight::protocol::from_json_key(j, "column", p.column, "ColumnDomain", "T", "column");
        datalight::protocol::from_json_key(j, "domain", p.domain, "ColumnDomain", "Domain", "domain");
    }
};

template <typename T>
struct adl_serializer<datalight::protocol::TupleDomain<T>>
{
    static void to_json(json & j, const datalight::protocol::TupleDomain<T> & tup)
    {
        datalight::protocol::List<datalight::protocol::ColumnDomain<T>> list;
        if (tup.domains != nullptr)
        {
            for (auto & el : *tup.domains)
            {
                datalight::protocol::ColumnDomain<T> domain;
                domain.column = el.first;
                domain.domain = el.second;
                list.push_back(domain);
            }
        }

        j["columnDomains"] = list;
    }

    static void from_json(const json & j, datalight::protocol::TupleDomain<T> & tup)
    {
        if (j.count("columnDomains") != 0U)
        {
            std::shared_ptr<datalight::protocol::Map<T, datalight::protocol::Domain>> map
                = std::make_shared<std::map<T, datalight::protocol::Domain>>();

            datalight::protocol::List<datalight::protocol::ColumnDomain<T>> list = j.at("columnDomains");
            for (const datalight::protocol::ColumnDomain<T> & value : list)
            {
                map->insert(std::make_pair(T(value.column), value.domain));
            }
            tup.domains = map;
        }
    }
};

template <typename T>
struct adl_serializer<datalight::protocol::TupleDomain<std::shared_ptr<T>>>
{
    static void to_json(json & j, const datalight::protocol::TupleDomain<std::shared_ptr<T>> & tup)
    {
        datalight::protocol::List<datalight::protocol::ColumnDomain<std::shared_ptr<T>>> list;
        if (tup.domains != nullptr)
        {
            for (auto & el : *tup.domains)
            {
                datalight::protocol::ColumnDomain<std::shared_ptr<T>> domain;
                domain.column = el.first;
                domain.domain = el.second;
                list.push_back(domain);
            }
        }

        j["columnDomains"] = list;
    }

    static void from_json(const json & j, datalight::protocol::TupleDomain<std::shared_ptr<T>> & tup)
    {
        if (j.count("columnDomains") != 0U)
        {
            auto map = std::make_shared<
                std::map<std::shared_ptr<T>, datalight::protocol::Domain, datalight::protocol::pointerDerefCompare<T>>>();

            datalight::protocol::List<datalight::protocol::ColumnDomain<std::shared_ptr<T>>> list = j.at("columnDomains");
            for (const datalight::protocol::ColumnDomain<std::shared_ptr<T>> & value : list)
            {
                map->insert(std::make_pair(std::shared_ptr<T>(value.column), value.domain));
            }
            tup.domains = map;
        }
    }
};

}
namespace datalight::protocol
{
struct RemoteSplit : public ConnectorSplit
{
    std::shared_ptr<ExchangeInput> exchangeInput = {};

    RemoteSplit() noexcept;
};
void to_json(json & j, const RemoteSplit & p);
void from_json(const json & j, RemoteSplit & p);
}
namespace datalight::protocol
{
struct HiveBucketProperty
{
    List<String> bucketedBy = {};
    BucketingVersion bucketingVersion = {};
    int bucketCount = {};
    List<SortingColumn> sortedBy = {};
};
void to_json(json & j, const HiveBucketProperty & p);
void from_json(const json & j, HiveBucketProperty & p);
}
namespace datalight::protocol
{
struct Storage
{
    StorageFormat storageFormat = {};
    std::shared_ptr<String> location = {};
    std::shared_ptr<HiveBucketProperty> bucketProperty = {};
    bool skewed = {};
    Map<String, String> serdeParameters = {};
};
void to_json(json & j, const Storage & p);
void from_json(const json & j, Storage & p);
}
namespace datalight::protocol
{
struct Table
{
    String databaseName = {};
    String tableName = {};
    std::shared_ptr<String> owner = {};
    String tableType = {};
    Storage storage = {};
    List<Column> dataColumns = {};
    List<Column> partitionColumns = {};
    Map<String, String> parameters = {};
    std::shared_ptr<String> viewOriginalText = {};
    std::shared_ptr<String> viewExpandedText = {};
    OptionalLong writeId = {};
};
void to_json(json & j, const Table & p);
void from_json(const json & j, Table & p);
}
namespace datalight::protocol
{
struct JsonSerializableEntry
{
    K key = {};
    V value = {};
};
void to_json(json & j, const JsonSerializableEntry & p);
void from_json(const json & j, JsonSerializableEntry & p);
}
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
namespace datalight::protocol
{

struct HivePageSinkMetadata
{
    SchemaTableName schemaTableName = {};
    std::shared_ptr<Table> table = {};
    // TODO Add modifiedPartitions
};
void to_json(json & j, const HivePageSinkMetadata & p);
void from_json(const json & j, HivePageSinkMetadata & p);

}
namespace datalight::protocol
{
struct DistinctLimitNode : public PlanNode
{
    std::shared_ptr<PlanNode> source = {};
    int64_t limit = {};
    bool partial = {};
    List<Symbol> distinctSymbols = {};
    std::shared_ptr<Symbol> hashSymbol = {};

    DistinctLimitNode() noexcept;
};
void to_json(json & j, const DistinctLimitNode & p);
void from_json(const json & j, DistinctLimitNode & p);
}
namespace datalight::protocol
{
struct FileSystemExchangeSinkHandle
{
    int partitionId = {};
    std::shared_ptr<String> secretKey = {};
};
void to_json(json & j, const FileSystemExchangeSinkHandle & p);
void from_json(const json & j, FileSystemExchangeSinkHandle & p);
}
namespace datalight::protocol
{
struct AcidTransaction
{
    AcidOperation operation = {};
    int64_t transactionId = {};
    int64_t writeId = {};
    std::shared_ptr<HiveUpdateProcessor> updateProcessor = {};
};
void to_json(json & j, const AcidTransaction & p);
void from_json(const json & j, AcidTransaction & p);
}
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
namespace datalight::protocol
{
enum class HiveStorageFormat
{
    ORC,
    DWRF,
    PARQUET,
    AVRO,
    RCBINARY,
    RCTEXT,
    SEQUENCEFILE,
    JSON,
    TEXTFILE,
    CSV,
    PAGEFILE
};

void to_json(json & j, const HiveStorageFormat & p);
void from_json(const json & j, HiveStorageFormat & p);

}
namespace datalight::protocol
{
struct HiveOutputTableHandle : public ConnectorOutputTableHandle
{
    String schemaName = {};
    String tableName = {};
    List<HiveColumnHandle> inputColumns = {};
    HivePageSinkMetadata pageSinkMetadata = {};
    LocationHandle locationHandle = {};
    HiveStorageFormat tableStorageFormat = {};
    HiveStorageFormat partitionStorageFormat = {};
    List<String> partitionedBy = {};
    std::shared_ptr<HiveBucketProperty> bucketProperty = {};
    String tableOwner = {};
    Map<String, String> additionalTableParameters = {};
    AcidTransaction transaction = {};
    bool external = {};
    bool retriesEnabled = {};

    HiveOutputTableHandle() noexcept;
};
void to_json(json & j, const HiveOutputTableHandle & p);
void from_json(const json & j, HiveOutputTableHandle & p);
}
namespace datalight::protocol
{
struct HiveBucketHandle
{
    List<HiveColumnHandle> columns = {};
    BucketingVersion bucketingVersion = {};
    int tableBucketCount = {};
    int readBucketCount = {};
    List<SortingColumn> sortedBy = {};
};
void to_json(json & j, const HiveBucketHandle & p);
void from_json(const json & j, HiveBucketHandle & p);
}
namespace datalight::protocol
{
struct OutputNode : public PlanNode
{
    std::shared_ptr<PlanNode> source = {};
    List<String> columns = {};
    List<Symbol> outputs = {};

    OutputNode() noexcept;
};
void to_json(json & j, const OutputNode & p);
void from_json(const json & j, OutputNode & p);
}
namespace datalight::protocol
{
struct HiveBucketFilter
{
    List<Integer> bucketsToKeep = {};
};
void to_json(json & j, const HiveBucketFilter & p);
void from_json(const json & j, HiveBucketFilter & p);
}
namespace datalight::protocol
{
enum class ColumnStatisticType
{
    MIN_VALUE,
    MAX_VALUE,
    NUMBER_OF_DISTINCT_VALUES,
    NUMBER_OF_DISTINCT_VALUES_SUMMARY,
    NUMBER_OF_NON_NULL_VALUES,
    NUMBER_OF_TRUE_VALUES,
    MAX_VALUE_SIZE_IN_BYTES,
    TOTAL_SIZE_IN_BYTES
};
extern void to_json(json & j, const ColumnStatisticType & e);
extern void from_json(const json & j, ColumnStatisticType & e);
}
namespace datalight::protocol
{
struct ColumnStatisticMetadata
{
    String columnName = {};
    ColumnStatisticType statisticType = {};
};
void to_json(json & j, const ColumnStatisticMetadata & p);
void from_json(const json & j, ColumnStatisticMetadata & p);
}
namespace datalight::protocol
{
struct HiveTableExecuteHandle : public ConnectorTableExecuteHandle
{
    String procedureName = {};
    std::shared_ptr<String> writeDeclarationId = {};
    std::shared_ptr<Long> maxScannedFileSize = {};
    String schemaName = {};
    String tableName = {};
    List<HiveColumnHandle> inputColumns = {};
    HivePageSinkMetadata pageSinkMetadata = {};
    LocationHandle locationHandle = {};
    std::shared_ptr<HiveBucketProperty> bucketProperty = {};
    HiveStorageFormat tableStorageFormat = {};
    HiveStorageFormat partitionStorageFormat = {};
    AcidTransaction transaction = {};
    bool retriesEnabled = {};

    HiveTableExecuteHandle() noexcept;
};
void to_json(json & j, const HiveTableExecuteHandle & p);
void from_json(const json & j, HiveTableExecuteHandle & p);
}
namespace datalight::protocol
{
struct ValueEntry
{
    Type type = {};
    Block block = {};
};
void to_json(json & j, const ValueEntry & p);
void from_json(const json & j, ValueEntry & p);
}
namespace datalight::protocol
{
struct EquatableValueSet : public ValueSet
{
    Type type = {};
    bool inclusive = {};
    List<ValueEntry> entries = {};

    EquatableValueSet() noexcept;
};
void to_json(json & j, const EquatableValueSet & p);
void from_json(const json & j, EquatableValueSet & p);
}
namespace datalight::protocol
{
struct FilterNode : public PlanNode
{
    std::shared_ptr<PlanNode> source = {};
    Expression predicate = {};

    FilterNode() noexcept;
};
void to_json(json & j, const FilterNode & p);
void from_json(const json & j, FilterNode & p);
}
namespace datalight::protocol
{
struct FileSystemExchangeSourceHandle : public ExchangeSourceHandle
{
    int partitionId = {};
    List<FileStatus> files = {};
    std::shared_ptr<String> secretKey = {};

    FileSystemExchangeSourceHandle() noexcept;
};
void to_json(json & j, const FileSystemExchangeSourceHandle & p);
void from_json(const json & j, FileSystemExchangeSourceHandle & p);
}
namespace datalight::protocol
{
struct GroupIdNode : public PlanNode
{
    std::shared_ptr<PlanNode> source = {};
    List<List<Symbol>> groupingSets = {};
    Map<Symbol, Symbol> groupingColumns = {};
    List<Symbol> aggregationArguments = {};
    Symbol groupIdSymbol = {};

    GroupIdNode() noexcept;
};
void to_json(json & j, const GroupIdNode & p);
void from_json(const json & j, GroupIdNode & p);
}
namespace datalight::protocol
{
struct SpoolingExchangeInput : public ExchangeInput
{
    List<std::shared_ptr<ExchangeSourceHandle>> exchangeSourceHandles = {};

    SpoolingExchangeInput() noexcept;
};
void to_json(json & j, const SpoolingExchangeInput & p);
void from_json(const json & j, SpoolingExchangeInput & p);
}
namespace datalight::protocol
{
struct AllOrNoneValueSet : public ValueSet
{
    Type type = {};
    bool all = {};

    AllOrNoneValueSet() noexcept;
};
void to_json(json & j, const AllOrNoneValueSet & p);
void from_json(const json & j, AllOrNoneValueSet & p);
}
namespace datalight::protocol
{
struct ServerInfo
{
    NodeVersion nodeVersion = {};
    String environment = {};
    bool coordinator = {};
    bool starting = {};
    std::shared_ptr<Duration> uptime = {};
};
void to_json(json & j, const ServerInfo & p);
void from_json(const json & j, ServerInfo & p);
}
namespace datalight::protocol
{
struct HiveTransactionHandle : public ConnectorTransactionHandle
{
    bool autoCommit = {};
    UUID uuid = {};

    HiveTransactionHandle() noexcept;
};
void to_json(json & j, const HiveTransactionHandle & p);
void from_json(const json & j, HiveTransactionHandle & p);
}
namespace datalight::protocol
{
struct LimitNode : public PlanNode
{
    std::shared_ptr<PlanNode> source = {};
    int64_t count = {};
    std::shared_ptr<OrderingScheme> tiesResolvingScheme = {};
    bool partial = {};
    List<Symbol> requiresPreSortedInputs = {};

    LimitNode() noexcept;
};
void to_json(json & j, const LimitNode & p);
void from_json(const json & j, LimitNode & p);
}
namespace datalight::protocol
{
struct HiveTableHandle : public ConnectorTableHandle
{
    String schemaName = {};
    String tableName = {};
    List<HiveColumnHandle> partitionColumns = {};
    List<HiveColumnHandle> dataColumns = {};
    TupleDomain<HiveColumnHandle> compactEffectivePredicate = {};
    TupleDomain<std::shared_ptr<ColumnHandle>> enforcedConstraint = {};
    std::shared_ptr<HiveBucketHandle> bucketHandle = {};
    std::shared_ptr<HiveBucketFilter> bucketFilter = {};
    std::shared_ptr<List<List<String>>> analyzePartitionValues = {};
    AcidTransaction transaction = {};

    HiveTableHandle() noexcept;
};
void to_json(json & j, const HiveTableHandle & p);
void from_json(const json & j, HiveTableHandle & p);
}
namespace datalight::protocol
{
struct SortedRangeSet : public ValueSet
{
    Type type = {};
    List<bool> inclusive = {};
    Block sortedRanges = {};

    SortedRangeSet() noexcept;
};
void to_json(json & j, const SortedRangeSet & p);
void from_json(const json & j, SortedRangeSet & p);
}
namespace datalight::protocol
{
struct FileSystemExchangeSinkInstanceHandle : public ExchangeSinkInstanceHandle
{
    FileSystemExchangeSinkHandle sinkHandle = {};
    URI outputDirectory = {};
    int outputPartitionCount = {};

    FileSystemExchangeSinkInstanceHandle() noexcept;
};
void to_json(json & j, const FileSystemExchangeSinkInstanceHandle & p);
void from_json(const json & j, FileSystemExchangeSinkInstanceHandle & p);
}
namespace datalight::protocol
{
struct RefreshMaterializedViewTarget : public WriterTarget
{
    TableHandle tableHandle = {};
    InsertTableHandle insertHandle = {};
    SchemaTableName schemaTableName = {};
    List<TableHandle> sourceTableHandles = {};

    RefreshMaterializedViewTarget() noexcept;
};
void to_json(json & j, const RefreshMaterializedViewTarget & p);
void from_json(const json & j, RefreshMaterializedViewTarget & p);
}
namespace datalight::protocol
{
enum class Step
{
    SINGLE,
    PARTIAL,
    FINAL
};
extern void to_json(json & j, const Step & e);
extern void from_json(const json & j, Step & e);
}
namespace datalight::protocol
{
struct TopNNode
{
    PlanNodeId id = {};
    std::shared_ptr<PlanNode> source = {};
    int64_t count = {};
    OrderingScheme orderingScheme = {};
    Step step = {};
};
void to_json(json & j, const TopNNode & p);
void from_json(const json & j, TopNNode & p);
}
namespace datalight::protocol
{
struct Assignments
{
    Map<Symbol, Expression> assignments = {};
};
void to_json(json & j, const Assignments & p);
void from_json(const json & j, Assignments & p);
}
namespace datalight::protocol
{
enum class SystemPartitionFunction
{
    SINGLE,
    HASH,
    ROUND_ROBIN,
    BROADCAST,
    UNKNOWN
};
extern void to_json(json & j, const SystemPartitionFunction & e);
extern void from_json(const json & j, SystemPartitionFunction & e);
}
namespace datalight::protocol
{
enum class SystemPartitioning
{
    SINGLE,
    FIXED,
    SOURCE,
    SCALED,
    COORDINATOR_ONLY,
    ARBITRARY
};
extern void to_json(json & j, const SystemPartitioning & e);
extern void from_json(const json & j, SystemPartitioning & e);
}
namespace datalight::protocol
{
struct SystemPartitioningHandle : public ConnectorPartitioningHandle
{
    SystemPartitioning partitioning = {};
    SystemPartitionFunction function = {};

    SystemPartitioningHandle() noexcept;
};
void to_json(json & j, const SystemPartitioningHandle & p);
void from_json(const json & j, SystemPartitioningHandle & p);
}
namespace datalight::protocol
{

template <typename T>
struct StatisticAggregationsDescriptor
{
    std::shared_ptr<Map<String, T>> grouping = {};
    std::shared_ptr<Map<TableStatisticType, T>> tableStatistics = {};
    //std::shared_ptr<Map<ColumnStatisticMetadata, T>> columnStatistics={};
};

//void to_json(json& j, const StatisticAggregationsDescriptor<T>& p);
//void from_json(const json& j, StatisticAggregationsDescriptor<T>& p);

}
namespace datalight::protocol
{
struct TableWriterNode : public PlanNode
{
    std::shared_ptr<PlanNode> source = {};
    std::shared_ptr<WriterTarget> target = {};
    Symbol rowCountSymbol = {};
    Symbol fragmentSymbol = {};
    List<Symbol> columns = {};
    List<String> columnNames = {};
    List<Symbol> notNullColumnSymbols = {};
    std::shared_ptr<PartitioningScheme> partitioningScheme = {};
    std::shared_ptr<PartitioningScheme> preferredPartitioningScheme = {};
    std::shared_ptr<StatisticAggregations> statisticsAggregation = {};
    std::shared_ptr<StatisticAggregationsDescriptor<Symbol>> statisticsAggregationDescriptor = {};

    TableWriterNode() noexcept;
};
void to_json(json & j, const TableWriterNode & p);
void from_json(const json & j, TableWriterNode & p);
}
namespace datalight::protocol
{
struct MemoryInfo
{
    int availableProcessors = {};
    MemoryPoolInfo pool = {};
};
void to_json(json & j, const MemoryInfo & p);
void from_json(const json & j, MemoryInfo & p);
}
namespace datalight::protocol
{
struct TableExecuteHandle
{
    CatalogName catalogName = {};
    std::shared_ptr<ConnectorTransactionHandle> transactionHandle = {};
    std::shared_ptr<ConnectorTableExecuteHandle> connectorHandle = {};
};
void to_json(json & j, const TableExecuteHandle & p);
void from_json(const json & j, TableExecuteHandle & p);
}
namespace datalight::protocol
{
struct TableExecuteTarget : public WriterTarget
{
    TableExecuteHandle executeHandle = {};
    std::shared_ptr<TableHandle> sourceHandle = {};
    SchemaTableName schemaTableName = {};
    bool reportingWrittenBytesSupported = {};

    TableExecuteTarget() noexcept;
};
void to_json(json & j, const TableExecuteTarget & p);
void from_json(const json & j, TableExecuteTarget & p);
}
namespace datalight::protocol
{
struct HiveInsertTableHandle : public ConnectorInsertTableHandle
{
    String schemaName = {};
    String tableName = {};
    List<HiveColumnHandle> inputColumns = {};
    HivePageSinkMetadata pageSinkMetadata = {};
    LocationHandle locationHandle = {};
    std::shared_ptr<HiveBucketProperty> bucketProperty = {};
    HiveStorageFormat tableStorageFormat = {};
    HiveStorageFormat partitionStorageFormat = {};
    AcidTransaction transaction = {};
    bool retriesEnabled = {};

    HiveInsertTableHandle() noexcept;
};
void to_json(json & j, const HiveInsertTableHandle & p);
void from_json(const json & j, HiveInsertTableHandle & p);
}
namespace datalight::protocol
{
struct TableScanNode : public PlanNode
{
    TableHandle table = {};
    List<Symbol> outputSymbols = {};
    Map<Symbol, std::shared_ptr<ColumnHandle>> assignments = {};
    bool updateTarget = {};
    std::shared_ptr<Boolean> useConnectorNodePartitioning = {};

    TableScanNode() noexcept;
};
void to_json(json & j, const TableScanNode & p);
void from_json(const json & j, TableScanNode & p);
}
namespace datalight::protocol
{
struct NodeStatus
{
    String nodeId = {};
    NodeVersion nodeVersion = {};
    String environment = {};
    bool coordinator = {};
    Duration uptime = {};
    String externalAddress = {};
    String internalAddress = {};
    MemoryInfo memoryInfo = {};
    int processors = {};
    double processCpuLoad = {};
    double systemCpuLoad = {};
    int64_t heapUsed = {};
    int64_t heapAvailable = {};
    int64_t nonHeapUsed = {};
};
void to_json(json & j, const NodeStatus & p);
void from_json(const json & j, NodeStatus & p);
}
namespace datalight::protocol
{
struct ProjectNode : public PlanNode
{
    std::shared_ptr<PlanNode> source = {};
    Assignments assignments = {};

    ProjectNode() noexcept;
};
void to_json(json & j, const ProjectNode & p);
void from_json(const json & j, ProjectNode & p);
}
namespace datalight::protocol
{
enum class NodeState
{
    ACTIVE,
    INACTIVE,
    SHUTTING_DOWN
};
extern void to_json(json & j, const NodeState & e);
extern void from_json(const json & j, NodeState & e);
}
